
== Calculation formulae

The formulae specified below define the expected behavior of software implementations of the deformation model.  A compliant software may use different formulae provided that for every location and time within the extents of a "realistic" deformation model the displacement calculated by the software is "practically identical" to that calculated from these formulae.  The terms "realistic" and "practically identical" are imprecise.  Within the context of deformation model usage, displacement differing by less than 0.1mm can be considered "practically identical".  

Grids can be defined either in terms of a geographic (latitude/longitude) or projected (easting/northing) CRS. Horizontal displacements and uncertainties are expressed as linear distances or, if the source and target CRSs are geographic, an angular measure.  Vertical displacements are expressed in linear units.

[[formula-spatial-interpolation]]
=== Spatial interpolation

This AS defines spatial functions by bilinear interpolation on a grid or set of grids.  In the future other interpolation methods or spatial representations may be supported.

[[formula-nested-grid-selection]]
==== Selection of spatial function grid

Spatial functions use a set of one or more grids. At a given location only one grid is used to calculate the spatial function displacement or uncertainty.  For each location within the valid extents of the model, the implementation must uniquely identify which grid, if any, applies. If no grid applies, then the displacement and uncertainty of the element at that location are both zero.

[[formula-bilinear-interpolation]]
==== Bilinear grid interpolation

Each grid of a spatial function is a regular grid in the interpolation CRS.  The coordinates of a grid node are defined as

x~i~ = x~o~ + i.x~s~ +
y~j~ = y~o~ + j.y~s~

// Note - this is less general than GGXF

where  x~o~, y~o~ are the coordinates of a reference point of the grid,  x~s~ and y~s~ are the grid spacing along the x and y axes respectively, and i and j are the column and row number of the grid node.  Note that the x and y grid spacing need not be equal.  For example, in a geographic  CRS where y is latitude and x is longitude, it may be preferable that x~s~ is approximately equal to y~s~/cos(y~m~), where y~m~ is the latitude of the middle of the grid, as this makes the grid cells approximately square.

Model components are calculated using bilinear interpolation with respect to x and y between the nodes at the corners of the grid cell within which the calculation point lies, as shown in <<image_bilinear_interpolation>>.  Each component of the displacement is calculated independently.

[[image_bilinear_interpolation]]
image::bilinear_interpolation.png[title="Bilinear interpolation on a grid cell",width=300,scalewidth=7cm]

Bilinear interpolation is defined as follows:

The calculation point (x,y) is located in the grid cell between columns i and i+1, and rows j and j+1.

Weights are assigned to these nodes using the formulae:

W~i,j~ = ((x~i+1~-x)/x~s~) * ((y~j+1~-y)/y~s~) +
W~i+1,j~ = ((x-x~i~)/x~s~) * ((y~j+1~-y)/y~s~) +
W~i,j+1~ = ((x~i+1~-x)/x~s~) * ((y-y~j~)/y~s~) +
W~i+1,j+1~ = ((x-x~i~)/x~s~)*((y-y~j~)/y~s~)

The model components at (x,y) are calculated as the weighted average of the values at the nodes as, e.g.:

de = W~i,j~.de~i,j~ + W~i+1,j~.de~i+1,j~ + W~i,j+1~.de~i,j+1~ + W~i+1,j+1~.de~i+1,j+1~

Uncertainties are interpolated from the grid node values using the same formulae.
// Above to be confirmed but above simplification may be more correct - model components from adjacent nodes are highly
// correlated so doesn't make sense to add as if they are independent.  Original text was
// 
// The displacement components de, dn, dh at (x,y) are calculated as the weighted average of the values at the nodes as, e.g.:
//
// de = W~i,j~.de~i,j~ + W~i+1,j~.de~i+1,j~ + W~i,j+1~.de~i,j+1~ + W~i+1,j+1~.de~i+1,j+1~
//
// The uncertainties eh, ev at (x,y) are calculated from the values at the nodes as, for example
//
// eh = √(W~i,j~*eh~i,j~^2^ + W~i+1,j~*eh~i+1,j~^2^ + W~i,j+1~*eh~i,j+1~^2^ + W~i+1,j+1~*eh~i+1,j+1~^2^)

[[formula-time-function]]
=== Time functions

The time function f(_t_) for an element evaluates a scalar value by which the spatial function displacement is multiplied to determine the displacement at time _t_. For example, in a velocity model the spatial model represents the displacement that happens in one year and the time function evaluates the scale factor f(t) applied to the displacement at time t as the number of years since a function reference epoch  t~0~, i.e. f(t)=(_t_ - t~0~).

The deformation model metadata defines a temporal extent for the model from T~min~ to T~max~. At times before T~min~ and after T~max~ every time function is considered undefined, and the model cannot be evaluated.

The time function is defined as the sum of one or more base functions. 

Each base function is one of the types listed in the following <<table-time-function-types>>.

[[table-time-function-types]]
.Base time function types
[cols="2,8a"]
[options="header"]
|===
| Time function type|Description
| velocity | Defines a scale factor that is linear with time.  When multiplied by the spatial function, it defines a constant velocity field, typically used to represent secular tectonic velocity.
| acceleration | Defines a rate of change of the velocity function.  This is sometimes used to model glacial isostatic adjustment.
| step | Defines an instantaneous displacement, typically used to model coseismic earthquake deformation.
| ramp | Defines displacement accumulating at a linear rate over a fixed period.  This can be used to represent post-seismic deformation or slow slip events.  Combining several ramp functions creates a piecewise linear time function that can emulate any time behavior to an arbitrary level of accuracy.
| exponential | Defines a displacement accumulating at an exponentially decaying rate after an event.  This is commonly used to approximate post-seismic deformation.  Often used in conjunction with a logarithmic model.
| logarithmic | Defines a displacement accumulating proportionally to the logarithm of elapsed time since an event.  This is commonly used to approximate post-seismic deformation.  It is often used in conjunction with an exponential model.
| hyperbolic tangent | Approximates time behavior observed in slow slip events.
| cyclic | Represents cyclic behavior, such as deformation due to seasonal hydrological loading.

|===


The following table lists the reference formulae for each type of time function.

[[table-time-functions]]
.Time function reference formulae
[cols="2,5a,5a"]
[options="header"]
|===
|Time function type|Function parameters|Formula (t~i,min~ &#8804; _t_ < t~i,max~)
|velocity| Function reference epoch t~0~ | f~r~(_t_) = (_t_ - t~0~)

|acceleration|Function reference epoch t~0~ |f~r~(_t_)= (_t_ - t~0~)^2^

|step | Event epoch t~v~ | f~r~(_t_) = 0 when t < t~v~, +
f~r~(_t_) = 1 when t &#8805; t~v~

|ramp|Start epoch t~s~ +
End epoch t~e~ | f~r~(_t_) =0 for _t_ < t~s~ +
f~r~(_t_) = (_t_-t~s~)/(t~e~-t~s~) for t~s~ &#8804; _t_ < t~e~ +
f~r~(_t_) = 1.0 for _t_ &#8805; t~e~

|exponential|Event epoch t~v~ +
Time constant &#964; | f~r~(_t_) = 0   for _t_ < t~v~ +
f~r~(_t_) = (1 - exp(-(_t_-t~v~)/&#964;)     for _t_ &#8805; t~v~

|logarithmic|Event epoch t~v~ +
Time constant &#964; | f~r~(_t_) = 0 for _t_ < t~v~ +
f~r~(_t_) = ln(1 + (_t_-t~v~)/&#964;) for  _t_ &#8805; t~v~

|hyperbolic tangent|Event epoch t~v~ +
Time constant &#964; | f~r~(_t_) = (1 + tanh( (_t_ - t~v~)/&#964;))/2 +
where tanh(x) = (e^x^ - e^-x^)/(e^x^ + e^-x^)

|cyclic|Frequency _f_ (cycles per year) +
Function reference epoch t~0~ |
f~r~(_t_) = sin(_f_(_t_ - t~0~)/2&#120587;)

|===


Each base time function is computed using the reference formula f~r~(_t_) as in <<table-time-functions>>.  The result can be modified by three epoch parameters, start epoch t~s~, end epoch t~e~, and function reference epoch t~0~, and a scale factor s.  (Note that the ramp function explicitly uses the start and end epoch; the velocity, acceleration, and cyclic functions explicitly use the function reference epoch.)

The base time function f(_t_) is evaluated from the reference function f~r~(_t_) using these epochs as follows:

* If the start epoch is defined, then the function value at the start epoch applies for all times before the start epoch.  If the end epoch is defined then the function value at the end epoch applies for all times after the end epoch.  That is:

+
--
f~1~(_t_) = f~r~(t~s~) if t~s~ is defined and _t_ < t~s~ +
f~1~(_t_) = f~r~(t~e~) if t~e~ is defined and _t_ > t~e~ +
f~1~(_t_) = f~r~(_t_) otherwise
--

* If the function reference epoch t~0~ is defined, then a constant is added to f~1~ so that it evaluates to zero at the function reference epoch. That is:

+
--
f~2~(_t_) = f~1~(_t_) - f~1~(t~0~) if t~0~ is defined +
f~2~(_t_) = f~1~(_t_) otherwise
-- 

* If the scale factor s is defined, then the function is multiplied by it:

+
--
f(_t_) = s.f~2~(_t_) if s is defined +
f(_t_) = f~2~(_t_) otherwise.
--

Note that the logarithmic function uses a natural logarithm (base _e_).  A base 10 logarithmic function can be emulated by using a scale factor of 1.0/ln(10.0) &#8776; 0.434294.

In these formulae all epochs _t_ are defined as a decimal year in the Proleptic Gregorian calendar. 

A UTC calendar date/time _yyyy_-_mm_-__dd__ __HH__:__MM__:__SS__  is converted to a decimal year as follows. The year number _yyyy_ of the UTC epoch forms the integer part of the decimal year. The fractional part of the decimal year is determined by dividing the number of seconds between the beginning of the year _yyyy_-01-01 00:00:00 and the date/time by the total number of seconds in the year (i.e. the number of seconds between _yyyy_-01-01 00:00:00 and _yyy1_-01-01 00:00:00, where _yyy1_ is __yyyy__+1).  An implementation is considered compliant whether or not it accounts for leap seconds.

Future versions of this AS may add new base time functions.

[[formula-elements]]
=== Combination of elements

To calculate the total displacement at a time and location, the displacement due to each element is calculated independently and summed. The total displacement is then applied to the coordinate. The same input position coordinate is used for each element. Deformation components are not applied sequentially, that is the input coordinate is not updated by the first element before being used to calculate the deformation of the second element.

At a given time and location the values obtained from each element are combined to determine the overall displacement. For example, if there are n components for which the spatial model calculates de as de~1~, de~2~, … to de~n~, and the time function evaluates to f~1~, f~2~, … to f~n~ then the total displacement de is

de = f~1~.de~1~+ f~2~.de~2~+ … + f~n~.de~n~

The uncertainty eh or ev is the root sum of squares (RSS) of the uncertainty values determined for each element, for example:

eh = √(f~1~^2^.eh~1~^2^+ f~2~^2^.eh~2~^2^+ … + f~n~^2^.eh~n~^2^)

[[formula-apply-displacement]]
=== Applying the total displacement to a coordinate

// Is there a better way to specify this without specifying units of 
// displacement and coordinates

The algorithm for applying a displacement to a coordinate depends on the units of the displacement and the source and target CRSs. 

If the source and target CRSs are projected CRSs, then the units must be meters and the east and north displacements are simply added to the easting and northing coordinates respectively.

If the source and target CRSs are geographic CRSs and the east and north displacement units are degrees, then the displacements are added to the latitude and longitude coordinates.

If the source and target CRSs are geographic and the east and north displacement units are meters, then the displacement components must be converted to degrees before being added to the latitude and longitude coordinates. The conversion from meters to degrees requires the ellipsoid parameters of the geographic CRS.

If a is the ellipsoid semi-major axis (e.g. 6378137.0), f is the flattening (e.g. 1.0/298.25722210), φ is the latitude, and λ is the longitude, then the corrections to latitude dφ and longitude dλ (in radians) are given by:


b = a.(1-f) +
dφ = dn.(b^2^sin^2^(φ)+a^2^cos^2^(φ))^3/2^/a^2^b^2^ +
dλ = de.√(b^2^sin^2^(φ)+a^2^cos^2^(φ))/a^2^cos(φ)

Note that these formulae do not account for the height of a point above the ellipsoidal surface. The deformation model is assumed to represent deformation on the ellipsoidal surface, so the actual east and north offset of a point above or below this surface will be slightly different to that defined in the model.

The vertical displacement is always simply added to the height coordinate.

[[formula-iterative-application]]
=== Iterative calculation of inverse transformspecification1ation

If the interpolation CRS is derived from the target CRS in a transformation, then the coordinate of a transformation point is not known until after the displacement has been applied to the source CRS coordinate to obtain the target CRS coordinate.  In this case an iterative calculation is required starting with an approximation for the interpolation CRS coordinate, and iteratively refining this approximation by calculating the target CRS coordinate.

The iterative calculation uses the following steps:

* Use the source CRS coordinate as an initial estimate for the target CRS coordinate
* At each iteration:
** Use the current estimate of the target CRS coordinate to determine the displacement that applies
** Apply this displacement to the source CRS coordinate to obtain a new estimate for the target CRS coordinate
** Calculate the difference between the current and new estimates of the target CRS coordinate
** If this difference is greater than the precision required for the inverse operation then iterate again, otherwise finish

Note that at the edge of the model it may not be possible to calculate the inverse transformation.  The model is undefined outside its spatial extent in the interpolation CRS.  If the transformation of a point near the edge of the model moves it to a location outside that extent, then the first step of the iterative calculation will fail.  This step uses the transformed coordinate as a first estimate for the untransformed coordinate.  However, that will be a point outside the model, so calculating the transformation at that point is not possible.  A more sophisticated algorithm could address this, for example using the nearest point within the spatial extent of the model at the first iteration.

[[formula-conversion-between-epochs]]
=== Calculation of deformation between two epochs

The displacements de, dn and du used to transform a coordinate between two epochs are calculated by replacing the time function values f~i~ used in <<formula-elements>> with the difference between the time function for the two epochs.  That is, to calculate the displacement from epoch t~1~ to epoch t~2~ the time function for the i^th^ element is calculated as:

f~i,t2-t1~ = f~i~(t~2~) - f~i~(t~1~)

When calculating displacement components this gives the same result as taking the difference between the displacement components calculated individually for each epoch.  However, the method described here must be used to give the correct value of the uncertainty of the displacement between two epochs.
