
== Calculation formulae

The formulae below define the expected behavior of software implementations of the deformation model. Whatever algorithm a software implementation may use it should produce numerically indistinguishable results to be a compliant implementation. This ensures the software implementation applies the model as intended by the producers.

In this specification the grid can be defined either in terms of a geographic (longitude/latitude) or projected (easting/northing) coordinate system. Displacements and uncertainties are expressed as linear distance except that the horizontal displacement may be an [.question]#angular distance# if the source and target coordinate systems are geographic.

[[formula-spatial-interpolation]]
=== Spatial interpolation

For spatial function and interpolation types defined in this specification, the position of the calculation point is used to identify a set of grid nodes for calculating displacement at that point and the weights to be assigned to the displacement at each of those nodes. The displacement values at the nodes are combined using a simple weighted average as described in <<formula-bilinear-interpolation>>.  For the horizontal components (east and north displacement) near the geographic poles an alternative method of combining the node horizontal displacements is described in <<formula-geocentric-bilinear-interpolation>>.

[[formula-nested-grid-selection]]
==== Selection of spatial function grid

Spatial functions are defined as a grid or a set of nested grids.  At a given position only one of the grids is used to calculate the spatial function displacement or uncertainty.  The selected grid is the smallest grid by area that contains the position.  The strictly nested arrangement of grids ensures that this is uniquely defined at any position.  If no grid in the spatial model contains the position then the displacement and uncertainty of the element at that location are both zero.

[[formula-bilinear-interpolation]]
==== Bilinear grid interpolation

Spatial functions may be represented as regular grids defined in an interpolation CRS. The coordinates of a grid node are given by

x~i~ = x~o~ + i.x~s~ +
y~j~ = y~o~ + j.y~s~

where  x~o~, y~o~ are the coordinates of a reference point of the grid,  x~s~ and y~s~ are the grid spacing along the x and y axes respectively, and i and j are the column and row number of the grid node.  Note that the x and y grid spacing need not be equal.  For example in a geographic interpolation coordinate system were x is longitude and y is latitude it may be preferable that x~s~ is approximately equal to y~s~/cos(y~m~), where y~m~ is the latitude of the middle of the grid, as this makes the grid cells approximately square (except at polar latitudes).

Displacement vector elements are calculated using bilinear interpolation with respect to x and y between the nodes at the corners of the grid cell within which the calculation point lies, as shown in <<image_bilinear_interpolation>>.  Each element of the displacement is calculated independently.

[[image_bilinear_interpolation]]
image::bilinear_interpolation.png[title="Bilinear interpolation on a grid cell",width=300,scalewidth=7cm]

Bilinear interpolation is defined as follows:

The calculation point (x,y) is located in the grid cell between columns i and i+1, and rows j and j+1.

The weights are assigned to these nodes using the formulae:

W~i,j~ = ((x~i+1~-x)/x~s~) * ((y~j+1~-y)/y~s~) +
W~i+1,j~ = ((x-x~i~)/x~s~) * ((y~j+1~-y)/y~s~) +
W~i,j+1~ = ((x~i+1~-x)/x~s~) * ((y-y~j~)/y~s~) +
W~i+1,j+1~ = ((x-x~i~)/x~s~)*((y-y~j~)/y~s~)

The displacement components de, dn, dh at (x,y) are calculated as the weighted average of the values at the nodes as, e.g.:

de = W~i,j~.de~i,j~ + W~i+1,j~.de~i+1,j~ + W~i,j+1~.de~i,j+1~ + W~i+1,j+1~.de~i+1,j+1~

The uncertainties eh, ev at (x,y) are calculated from the values at the nodes as, for example

eh = √(W~i,j~*eh~i,j~^2^ + W~i+1,j~*eh~i+1,j~^2^ + W~i,j+1~*eh~i,j+1~^2^ + W~i+1,j+1~*eh~i+1,j+1~^2^)

[[formula-geocentric-bilinear-interpolation]]
==== Geocentric bilinear grid interpolation

A simple average of the east and north displacements may not be appropriate where a grid cell spans a wide longitude range, typically for grids in polar regions.  In this situation the directions of the east and north vectors may be quite different at nodes being averaged, as shown in <<image-near-pole-axes>> where their directions at nodes A and B and the evaluation point P differ significantly.

[[image-near-pole-axes]]
image::geocentric_bilinear_interpolation.png[title="East and north directions at near pole grid axes", width=200,scalewidth=7cm]

In this situation the bilinear interpolation of vector components can be adapted by reparameterizing the vectors to a common set of axes before forming the weighted average.

The geocentric bilinear interpolation method converts the displacement components from east and north components to geocentric X, Y, and Z components. These are consistently aligned at the grid nodes and can be scaled and summed using the bilinear interpolation formulae in <<formula-bilinear-interpolation>> to calculate the X, Y, Z components of displacement at the calculation point, which are then converted back to east and north components at the calculation point.

At longitude λ and latitude φ the geocentric displacement components dx, dy, dz are calculated from the east and north components de, dn as:

dx~i,j~ = -de~i,j~.sin(λ~i,j~) - dn~i,j~.cos(λ~i,j~).sin(φ~i,j~) +
dy~i,j~ = de~i,j~.cos(λ~i,j~) - dn~i,j~.sin(λ~i,j~).sin(φ~i,j~) +
dz~i,j~ = dn~i,j~.cos(φ~i,j~)

The X, Y, and Z directions are the same at any location, so the dx, dy, and dz displacements can be interpolated independently using bilinear interpolation, e.g.:

dx = W~i,j~.dx~i,j~ + W~i+1,j~.dx~i+1,j~ + W~i,j+1~.dx~i,j+1~ + W~i+1,j+1~.dx~i+1,j+1~

where the weights W~i,j~ are as defined in <<formula-bilinear-interpolation>>.

The displacement at the calculation point is then calculated as:

de = -dx.sin(λ) + dy * cos (λ) +
dn = -dx.cos(λ).sin(φ) - dy.sin(λ).sin(φ) + dz.cos(φ)

Note that this is only used to determine the horizontal displacement. The vertical displacement and uncertainties are computed using the bilinear formula above.

[[formula-time-function]]
=== Time functions

The time function f(_t_) for an element evaluates a scalar value by which the spatial function displacement is multiplied to determine the displacement at time _t_. For example, in a velocity model the spatial model represents the displacement that happens in one year and the time function evaluates the scale factor f(t) applied to the displacement at time t as the number of years since a reference epoch  t~0~, i.e. f(t)=(_t_ - t~0~).

The deformation model metadata defines a temporal extent for the model from T~min~ to T~max~. At times before T~min~ and after T~max~ every time function is considered undefined and the model cannot be evaluated.

Time functions are parameterized as a function of decimal years. For example, velocities are expressed meters/year.

The conversion of a UTC epoch _yyyy_-_mm_-__dd__T__HH__:__MM__:__SS__Z to decimal years is implemented as follows. The year number _yyyy_ of the UTC epoch forms the integer part of the decimal year. The fractional part of the decimal year is determined by dividing the number of seconds between the beginning of the year _yyyy_-01-01T00:00:00Z and the epoch by the total number of seconds in the year (i.e. the number of seconds between _yyyy_-01-01T00:00:00Z and _yyy1_-01-01T00:00:00Z, where _yyy1_ is __yyyy__+1).

Note that there is a small ambiguity in this formulation due to the occasional introduction of leap seconds. This impacts calculations because 1) it is not known at the beginning of the year whether a leap second will be added, and 2) standard software libraries used to implement the time functions may not include leap seconds, and if they do there will often be a delay before updates including leap seconds are distributed to users. Since leap seconds impart no practical difference to the deformation model calculations the decimal year is considered compliant whether or not it accounts for leap seconds — there are two nominally correct answers.

The time function is defined as the sum of one or more of the following base functions. In this table some functions include optional parameters which are indicated by italics.

.Time functions
[cols="2,5a,5a"]
[options="header"]
|===
|Time function type|Parameters|Formula (t~i,min~ &#8804; _t_ < t~i,max~)
|velocity| Function reference epoch t~0~ +
_Start epoch_ t~s~ +
_End epoch_ t~e~| f(_t_) = _t_ - t~0~ +
f(_t_) = f(t~s~) for _t_ < t~s~ if t~s~ is defined +
f(_t_) = f(t~e~) for _t_ < t~e~ if t~e~ is defined

|step | Step epoch t~s~ |f(__t__) = 0 when t < t~s~, +
f(__t__) = 1 when t &#8805; t~s~
|reverse step | Step epoch t~s~ |f(__t__) = -1 when t < t~s~, +
f(__t__) = 0 when t &#8805; t~s~

|ramp|Start epoch t~s~ +
Start scale factor f~s~ +
End epoch t~e~ +
End scale factor f~e~ |f(_t_) = f~s~ for _t_ < t~s~ +
f(_t_) = (f~s~.(t~e~ – _t_) + f~e~.(_t_-t~s~))/(t~e~-t~s~) for t~s~ &#8804; _t_ < t~e~ +
f(_t_) = f~e~ for _t_ &#8805; t~e~

|exponential|Start epoch t~s~ +
Start amplitude &#945;~0~ +
Final amplitude &#945;~∞~ +
Decay constant θ +
_End epoch_ t~e~ | f(_t_) = 0   for _t_ < t~s~ +
f(_t_) = &#945;~0~ + (&#945;~∞~-&#945;~0~).(1 - exp(-(_t_-t~s~)/θ))     for _t_ &#8805; t~s~ +
f(_t_) = f(t~e~) for _t_ > t~e~ if t~e~ is defined

|logarithmic|Start epoch t~s~ +
Scale factor &#945; +
Time constant &#964; +
_End epoch_ t~e~| f(_t_) = 0 for _t_ < t~s~ +
f(_t_) = &#945;.ln(1 + (_t_-t~s~)/&#964;) for t~s~ &#8804; _t_ +
f(_t_) = f(t~e~) for _t_ > t~e~ if t~e~ is defined

|acceleration|Function reference epoch t~0~ +
Acceleration _a_ +
_Start epoch_ t~s~ +
_End epoch_ t~e~|f(_t_)= _a_.(_t_ - t~0~)^2^  +
f(_t_) = f(t~s~) for _t_ < t~s~ if t~s~ is defined +
f(_t_) = f(t~e~) for _t_ > t~e~ if t~e~ is defined

|hyperbolic tangent|Start epoch t~s~ +
End epoch t~1~ +
Time constant &#964; +
Scale factor &#945;|f(_t_)= 0 for _t_ < t~s~ +
f(_t_) = &#945;/2 + A.tanh((_t_ - t~r~)/&#964;) for _t_ &#8805; t~s~ and _t_ < t~e~ +
f(_t_) = &#945; for _t_ &#8805; t~e~ +
where: +
t~r~ = (t~s~ + t~e~)/2 +
A = &#945;/2.tanh(t~e~-t~r~) +
tanh(x) = (e^x^ - e^-x^)/(e^x^ + e^-x^)

|cyclic|Frequency _f_ (cycles per year) +
Function reference epoch t~0~ +
Cosine amplitude &#945; +
Sine amplitude &#946;|
f(_t_) = &#945;cos(_f_(_t_ - t~0~)/2&#120587;)
+ &#946;sin(_f_(_t_ - t~0~)/2&#120587;)

|===

The step and reverse step functions are specializations of the ramp function provided to improve simplicity and readability for the two most common uses of it.

Future versions of this specification may add new base functions as required.

[[formula-elements]]
=== Combination of elements

To calculate the total deformation at a time and location, the displacement due to each element is calculated independently and summed. The total displacement is then applied to the coordinate. Displacement uncertainty is calculated similarly. See the formula below.  The same input position coordinate is used for each element. Deformation components are not applied sequentially, that is the input coordinate is not updated by the first element before being used to calculate the deformation of the second element.

At a given time and location the values obtained from each element are combined to determine the overall. For example, if there are n components for which the spatial model calculates de as de~1~, de~2~, … to de~n~, and the time function evaluates to f~1~, f~2~, … to f~n~ then the total displacement de is

de = f~1~.de~1~+ f~2~.de~2~+ … + f~n~.de~n~

The uncertainty eh or ev is the root sum of squares (RSS) of the uncertainty values determined for each element. For example,

eh = √(f~1~^2^.eh~1~^2^+ f~2~^2^.eh~2~^2^+ … + f~n~^2^.eh~n~^2^)

[formula-apply-displacement]
=== Applying the total displacement to a coordinate

The method used to add the calculated displacement to the reference coordinate is defined in the deformation model metadata. Two methods are defined - _addition_ described in <<formula-displacement-addition>> and _geocentric addition_ described in <<formula-displacement-geocentric-addition>>. The _addition_ method simply adds the displacements to the coordinates.  The _geocentric_ method accounts for the difference between a linear east offset and a longitude offset in polar regions. It is only applicable if the displacements are expressed as linear distance (e.g. meters) and the source and target coordinate system are geographic.

If the interpolation coordinate system is directly related to the source or target coordinate systems then applying the  displacement to a point may change its coordinate in the interpolation coordinate system, which in turn may change the calculated value of displacement.  In this case the calculation and application of displacement to an input coordinate may require iteration, as described in <<formula-iterative-application>>.

[[formula-displacement-addition]]
==== Addition method

The method of applying a displacement to a coordinate depends on the units of the displacement and the type of the source and target coordinate systems. For geographic coordinate systems the method described here does not apply close to the poles. See the section below “calculation horizontal deformation near the poles” for details.

If the source and target coordinate systems are projected coordinate systems then the units must be meters and the east and north displacements are simply added to the easting, northing coordinates.

If the source and target coordinate systems are geographic coordinate systems and the east and north displacement units are degrees, then the displacements are added to the longitude and latitude coordinates.

If the source and target coordinate systems are geographic and the east and north displacement units are meters then the displacement components must be converted to degrees before being added to the longitude and latitude coordinates. The conversion from meters to degrees requires the ellipsoid parameters of the geographic coordinate system.

If a is the ellipsoid semi-major axis (e.g. 6378137.0), f is the flattening (e.g. 1.0/298.25722210), λ is the latitude, and φ is the longitude then corrections to longitude and latitude (in radians) are given by:


b = a.(1-f) +
dλ = de.√(b^2^sin^2^(φ)+a^2^cos^2^(φ))/a^2^cos(φ) +
dφ = dn.(b^2^sin^2^(φ)+a^2^cos^2^(φ))^3/2^/a^2^b^2^


The vertical displacement is always in meters and is simply added to the height coordinate.

[[formula-displacement-geocentric-addition]]
==== Geocentric addition method

The geocentric method can be applied if the spatial function uses a geographic coordinate system and displacements are given in meters. In this case the horizontal displacements are first converted to geocentric (XYZ) displacements, then added to the geocentric coordinates, and finally converted back to geographic coordinates. The vertical coordinate is always calculated by simple addition of the vertical displacement to the vertical coordinate.

This method may be applicable for points near the pole, where simple addition of displacements to the geographic coordinates may not give the desired result. This is illustrated in <<image-near-pole-east-displacement>> where the grey vector shows the result of adding an east displacement to the longitude coordinate, and the black vector shows the result applying the same east displacement in the direction of the east vector component. Close to the pole applying a displacement in the direction of the east vector gives a different result to hanging the east (longitude) coordinate.

[[image-near-pole-east-displacement]]
image::near_pole_east_displacement.png[title="Comparison of vector and angular displacement near a pole",width=200,scalewidth=7cm,align="right"]

Moving away from the pole this discrepancy becomes less significant. For a point at distance R from the pole with a displacement d, the difference is approximately d*(1-cos(d/R)), or approximately d^3^/2R^2^. or example, a 1 m east displacement 10 km from the pole would have an error of 10^-8^m, but increases rapidly as one approaches closer to the pole.

TBC _Add formulae for conversion lat/lon to XYZ and vice versa_

Standard formulae are used to convert geographic coordinates to and from geocentric coordinates. The input ellipsoidal height is set to zero before converting to Cartesian coordinates, and the resultant ellipsoidal height after converting back to geographic coordinates is discarded.

The horizontal components of displacement are converted to Cartesian (X,Y,Z) components using the same formulae as described for the geocentric bilinear method in Sec. 6.1.3.

[[formula-iterative-application]]
=== Iterative application of displacement

Calculating the inverse of the model requires an iterative solution if the interpolation coordinate system is dependent on the output coordinate system. The coordinate in the interpolation coordinate reference system is required to evaluate the displacement, but that coordinate is not known until the displacement has been calculated and applied to the input coordinate to derive the output coordinate.

This will apply in a forward transformation if the interpolation coordinate system is dependent on the target coordinate system, and in a reverse transformation if it is dependent on the source coordinate system.

The iterative calculation uses the following steps:

* using the input coordinate as an initial estimate for the output coordinate
* at each iteration:
** use the current estimate of the output coordinate to determine that displacement that applies
** apply this displacement to the input coordinate to obtain a new estimate for the output coordinate
** calculate the difference between the current and new estimates of the output coordinate
** if this difference is less than the precision required for the inverse operation then finish

[[formula-14prm-transformation]]
=== Calculation of the 14 parameter transformation

If the model includes a link:#206ipza[_14 parameter transformation_] then this is applied to the coordinates after the model is calculated and applied in a forward transformation. In an inverse transformation it is applied before the model components are applied to the coordinate.

TBC _The 14 parameter transformation formulae need to be included here_
