
== Calculation formulae

The formulae below define the expected behavior of software implementations of the deformation model. Whatever algorithm a software implementation may use it should produce numerically indistinguishable results to be a compliant implementation. This ensures the software implementation applies the model as intended by the producers.

In this specification the grid can be defined either in terms of a geographic (longitude/latitude) or projected (easting/northing) coordinate system. Displacements and uncertainties are expressed as linear distance except that the horizontal displacement may be an [.question]#angular distance# if the source and target coordinate systems are geographic.

[[formula-spatial-interpolation]]
=== Spatial interpolation

This specification defines spatial functions by bilinear interpolation on a grid or set of grids.  In the future other interpolation methods or spatial representations may be supported.

[[formula-nested-grid-selection]]
==== Selection of spatial function grid

Spatial functions are using a set of one or more grids.  At a given position only one of the grids is used to calculate the spatial function displacement or uncertainty.  The implementation must uniquely identify the grid, if any, that applies at any location within the valid extents of the model.  If no grid applies at a location then the displacement and uncertainty of the element at that location are both zero.

[[formula-bilinear-interpolation]]
==== Bilinear grid interpolation

Each grid of a spatial function is a regular grids defined in an interpolation CRS. The coordinates of a grid node are given by

x~i~ = x~o~ + i.x~s~ +
y~j~ = y~o~ + j.y~s~

// Note - this is less general than GGXF

where  x~o~, y~o~ are the coordinates of a reference point of the grid,  x~s~ and y~s~ are the grid spacing along the x and y axes respectively, and i and j are the column and row number of the grid node.  Note that the x and y grid spacing need not be equal.  For example, in a geographic interpolation coordinate system where x is longitude and y is latitude it may be preferable that x~s~ is approximately equal to y~s~/cos(y~m~), where y~m~ is the latitude of the middle of the grid, as this makes the grid cells approximately square (except at polar latitudes).

Model components are calculated using bilinear interpolation with respect to x and y between the nodes at the corners of the grid cell within which the calculation point lies, as shown in <<image_bilinear_interpolation>>.  Each component of the displacement is calculated independently.

[[image_bilinear_interpolation]]
image::bilinear_interpolation.png[title="Bilinear interpolation on a grid cell",width=300,scalewidth=7cm]

Bilinear interpolation is defined as follows:

The calculation point (x,y) is located in the grid cell between columns i and i+1, and rows j and j+1.

The weights are assigned to these nodes using the formulae:

W~i,j~ = ((x~i+1~-x)/x~s~) * ((y~j+1~-y)/y~s~) +
W~i+1,j~ = ((x-x~i~)/x~s~) * ((y~j+1~-y)/y~s~) +
W~i,j+1~ = ((x~i+1~-x)/x~s~) * ((y-y~j~)/y~s~) +
W~i+1,j+1~ = ((x-x~i~)/x~s~)*((y-y~j~)/y~s~)

The model components at (x,y) are calculated as the weighted average of the values at the nodes as, e.g.:

de = W~i,j~.de~i,j~ + W~i+1,j~.de~i+1,j~ + W~i,j+1~.de~i,j+1~ + W~i+1,j+1~.de~i+1,j+1~

Uncertainties are interpolated from the grid node values using the same formulae.
// Above to be confirmed but above simplification may be more correct - model components from adjacent nodes are highly
// correlated so doesn't make sense to add as if they are independent.  Original text was
// 
// The displacement components de, dn, dh at (x,y) are calculated as the weighted average of the values at the nodes as, e.g.:
//
// de = W~i,j~.de~i,j~ + W~i+1,j~.de~i+1,j~ + W~i,j+1~.de~i,j+1~ + W~i+1,j+1~.de~i+1,j+1~
//
// The uncertainties eh, ev at (x,y) are calculated from the values at the nodes as, for example
//
// eh = √(W~i,j~*eh~i,j~^2^ + W~i+1,j~*eh~i+1,j~^2^ + W~i,j+1~*eh~i,j+1~^2^ + W~i+1,j+1~*eh~i+1,j+1~^2^)

[[formula-time-function]]
=== Time functions

The time function f(_t_) for an element evaluates a scalar value by which the spatial function displacement is multiplied to determine the displacement at time _t_. For example, in a velocity model the spatial model represents the displacement that happens in one year and the time function evaluates the scale factor f(t) applied to the displacement at time t as the number of years since a function reference epoch  t~0~, i.e. f(t)=(_t_ - t~0~).

The deformation model metadata defines a temporal extent for the model from T~min~ to T~max~. At times before T~min~ and after T~max~ every time function is considered undefined and the model cannot be evaluated.

The time function is defined as the sum of one or more base functions. 

Each base time function is one of the types listed in the following table.

[[table-time-function-types]]
.Base time function types
[cols="2,8a"]
[options="header"]
|===
| Time function type|Description
| velocity | Defines a scale factor that is linear with time.  When multiplied by the spatial function this defines a constant velocity field, typically used to represent secular tectonic velocity.
| acceleration | Defines a rate of change of the velocity function.  This may be used where the velocity is changing at a constant rate.  This is sometimes used to model glacial isostatic adjustment.
| step | Defines an instantaneous change of displacement, typically used to model coseismic earthquake deformation.
| ramp | Defines displacement accumulating at a linear rate over a fixed period of time.  This can be used to simplistically represent post-seismic deformation.  In particular, combining several ramp functions can be used to create a piecewise linear time function that can emulate any time behavior to an arbitrary level of accuracy.
| exponential | Defines a displacement accumulating at an exponentially decaying rate after an event.  This is commonly used to approximate post-seismic deformation.  Often used in conjunction with a logarithmic model.
| logarithmic | Defines a displacement accumulating proportionally to the logarithm of elapsed time since an event.  This is commonly used to approximate post-seismic deformation.  It is often used in conjunction with an exponential model.
| hyperbolic tangent | Approximates a time behavior observed in slow slip events.
| cyclic | Represents cyclic behavior, such as deformation due to seasonal groundwater loading.

|===


The following table lists the reference formulae for each type of time function.

[[table-time-functions]]
.Time function reference formulae
[cols="2,5a,5a"]
[options="header"]
|===
|Time function type|Parameters|Formula (t~i,min~ &#8804; _t_ < t~i,max~)
|velocity| Function reference epoch t~0~ | f~r~(_t_) = (_t_ - t~0~)

|acceleration|Function reference epoch t~0~ |f~r~(_t_)= (_t_ - t~0~)^2^

|step | Event epoch t~v~ | f~r~(_t_) = 0 when t < t~v~, +
f~r~(_t_) = 1 when t &#8805; t~v~

|ramp|Start epoch t~s~ +
End epoch t~e~ | f~r~(_t_) =0 for _t_ < t~s~ +
f~r~(_t_) = (_t_-t~s~)/(t~e~-t~s~) for t~s~ &#8804; _t_ < t~e~ +
f~r~(_t_) = 1.0 for _t_ &#8805; t~e~

|exponential|Event epoch t~v~ +
Time constant &#964; | f~r~(_t_) = 0   for _t_ < t~v~ +
f~r~(_t_) = (1 - exp(-(_t_-t~v~)/&#964;)     for _t_ &#8805; t~v~

|logarithmic|Event epoch t~v~ +
Time constant &#964; | f~r~(_t_) = 0 for _t_ < t~v~ +
f~r~(_t_) = ln(1 + (_t_-t~v~)/&#964;) for  _t_ &#8805; t~v~

|hyperbolic tangent|Event epoch t~v~ +
Time constant &#964; | f~r~(_t_) = (1 + tanh( (_t_ - t~v~)/&#964;))/2 +
where tanh(x) = (e^x^ - e^-x^)/(e^x^ + e^-x^)

|cyclic|Frequency _f_ (cycles per year) +
Function reference epoch t~0~ |
f~r~(_t_) = sin(_f_(_t_ - t~0~)/2&#120587;)

|===


Each base time function is computed using the reference formula f~r~(_t_) as in table <<table-time-functions>> above.  The result can be modified by three epoch parameters, start epoch t~s~, end epoch t~e~, and function reference epoch t~0~, and a scale factor s.  (Note that the ramp function explicitly uses the start and end epoch, and the velocity, acceleration, and cyclic functions explicitly use the function reference epoch.)

The base time function f(_t_) is evaluated from the reference function f~r~(_t_) using these epochs as follows:

* If the start epoch is defined then the function is evaluated at the start epoch for all times before the start epoch.  If the end epoch is defined then the function is evaluated at the end epoch for all times after the end epoch.  That is:

+
--
f~1~(_t_) = f~r~(t~s~) if t~s~ is defined and _t_ < t~s~ +
f~1~(_t_) = f~r~(t~e~) if t~e~ is defined and _t_ > t~e~ +
f~1~(_t_) = f~r~(_t_) otherwise
--

* If the function reference epoch t~0~ is defined then a constant is added to f~1~ so that it evaluates to zero at the function reference epoch. That is:

+
--
f~2~(_t_) = f~1~(_t_) - f~1~(t~0~) if t~0~ is defined +
f~2~(_t_) = f~1~(_t_) otherwise
-- 

* If the scale factor s is defined then the function is multiplied by it:

+
--
f(_t_) = s.f~2~(_t_) if s is defined +
f(_t_) = f~2~(_t_) otherwise.
--

In these formulae all epochs _t_ are defined as a decimal year. 

A date/time _yyyy_-_mm_-__dd__T__HH__:__MM__:__SS__  is converted to a decimal year as follows. The year number _yyyy_ of the UTC epoch forms the integer part of the decimal year. The fractional part of the decimal year is determined by dividing the number of seconds between the beginning of the year _yyyy_-01-01T00:00:00Z and the date/time by the total number of seconds in the year (i.e. the number of seconds between _yyyy_-01-01T00:00:00Z and _yyy1_-01-01T00:00:00Z, where _yyy1_ is __yyyy__+1).

Note that there is a small ambiguity in this formulation due to the occasional introduction of leap seconds. This impacts calculations because 1) it is not known at the beginning of the year whether a leap second will be added, and 2) standard software libraries used to implement the time functions may not include leap seconds, and if they do there will often be a delay before updates including leap seconds are distributed to users.  In all realistic usages, apart from the step function at the event epoch, the difference in deformation from one second to the next is insignificant.  

Since leap seconds impart no practical difference to the deformation model calculations the decimal year is considered compliant whether or not it accounts for leap seconds - there are two nominally correct answers.

Future versions of this specification may add new base time functions.

[[formula-elements]]
=== Combination of elements

To calculate the total displacement at a time and location, the displacement due to each element is calculated independently and summed. The total displacement is then applied to the coordinate. Displacement uncertainty is calculated similarly using the formula below.  The same input position coordinate is used for each element. Deformation components are not applied sequentially, that is the input coordinate is not updated by the first element before being used to calculate the deformation of the second element.

At a given time and location the values obtained from each element are combined to determine the overall displacement. For example, if there are n components for which the spatial model calculates de as de~1~, de~2~, … to de~n~, and the time function evaluates to f~1~, f~2~, … to f~n~ then the total displacement de is

de = f~1~.de~1~+ f~2~.de~2~+ … + f~n~.de~n~

The uncertainty eh or ev is the root sum of squares (RSS) of the uncertainty values determined for each element. For example,

eh = √(f~1~^2^.eh~1~^2^+ f~2~^2^.eh~2~^2^+ … + f~n~^2^.eh~n~^2^)

[[formula-apply-displacement]]
=== Applying the total displacement to a coordinate

// Is there a better way to specify this without specifying units of 
// displacement and coordinates

The algorithm for applying a displacement to a coordinate depends on the units of the displacement and the type of the source and target coordinate systems. 

If the source and target coordinate systems are projected coordinate systems then the units must be meters and the east and north displacements are simply added to the easting, northing coordinates.

If the source and target coordinate systems are geographic coordinate systems and the east and north displacement units are degrees, then the displacements are added to the longitude and latitude coordinates.

If the source and target coordinate systems are geographic and the east and north displacement units are meters then the displacement components must be converted to degrees before being added to the longitude and latitude coordinates. The conversion from meters to degrees requires the ellipsoid parameters of the geographic coordinate system.

If a is the ellipsoid semi-major axis (e.g. 6378137.0), f is the flattening (e.g. 1.0/298.25722210), λ is the longitude, and φ is the latitude then corrections to longitude dλ and latitude dφ (in radians) are given by:


b = a.(1-f) +
dλ = de.√(b^2^sin^2^(φ)+a^2^cos^2^(φ))/a^2^cos(φ) +
dφ = dn.(b^2^sin^2^(φ)+a^2^cos^2^(φ))^3/2^/a^2^b^2^

Note that this formula does not account for the height of a calculation point above the ellipsoidal surface. The deformation model is assumed to represent deformation on the ellipsoidal surface, so the actual east and north offset of a point above or below this surface will be slightly different to that defined in the model.

The vertical displacement is always simply added to the height coordinate.

[[formula-iterative-application]]
=== Iterative calculation of inverse transformation

If the interpolation coordinate system is directly related to the source or target coordinate systems then applying the  displacement to a point may change its coordinate in the interpolation coordinate system, which in turn may change the calculated value of displacement.  In this case the calculation and application of displacement to an input coordinate may require iteration, as described in <<formula-iterative-application>>.

Calculating the inverse of the model requires an iterative solution if the interpolation coordinate system is dependent on the output coordinate system. The coordinate in the interpolation coordinate reference system is required to evaluate the displacement, but that coordinate is not known until the displacement has been calculated and applied to the input coordinate to derive the output coordinate.

This will apply in a forward transformation if the interpolation coordinate system is dependent on the target coordinate system, and in a reverse transformation if it is dependent on the source coordinate system.

The iterative calculation uses the following steps:

* use the input coordinate as an initial estimate for the output coordinate
* at each iteration:
** use the current estimate of the output coordinate to determine the displacement that applies
** apply this displacement to the input coordinate to obtain a new estimate for the output coordinate
** calculate the difference between the current and new estimates of the output coordinate
** if this difference is greater than the precision required for the inverse operation then iterate again, otherwise finish

Note that at the edge of the model it may not be possible to calculate the inverse transformation.  The model is undefined outside its spatial extent in the interpolation coordinate system.  If the transformation of a point near the edge of the model moves it to a location outside that extent, then the first step of the iterative calculation will fail.  This step uses the transformed coordinate as a first estimate for the untransformed coordinate.  However that will be a point outside the model, so calculating the transformation at that point is not possible.  A more sophisticated algorithm could address this, for example using the nearest point within the spatial extent of the model at the first iteration.

[[formula-conversion-between-epochs]]
=== Calculation of deformation between two epochs

The displacement de, dn and du to transform a coordinate between two epochs is calculated in a similar way to above except that the time functions are evaluated by taking the difference between the values at each epoch.  

To calculate the displacement from epoch t~0~ to epoch t~1~ the time factors in <<formula-elements>> are calculated for the i^th^ element as:

f~i,t1-t0~ = f~i~(t~1~) - f~i~(t~0~)

Note that for calculating displacement components this gives the same result as taking the difference between the displacement components calculated individually for each epoch.  However, this method must be used to give the correct value of the uncertainty of the displacement between two epochs.
