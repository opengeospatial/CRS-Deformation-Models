
== Calculation formulae

The formulae below define the expected behavior of software implementations of the deformation model. Whatever algorithm a software implementation may use it should produce numerically indistinguishable results to be a compliant implementation. This ensures the software implementation applies the model as intended by the producers.

In this specification the grid can be defined either in terms of a geographic (longitude/latitude) or projected (easting/northing) coordinate system. Displacements and uncertainties are expressed as linear distance except that the horizontal displacement may be an [.question]#angular distance# if the source and target coordinate systems are geographic.

[[formula-spatial-interpolation]]
=== Spatial interpolation

For spatial function and interpolation types defined in this specification, the position of the calculation point is used to identify a set of grid nodes for calculating displacement at that point and the weights to be assigned to the displacement at each of those nodes. The displacement values at the nodes are combined using a simple weighted average as described in <<formula-bilinear-interpolation>>.  For the horizontal components (east and north displacement) near the geographic poles an alternative method of combining the node horizontal displacements is described in <<formula-geocentric-bilinear-interpolation>>.

[[formula-nested-grid-selection]]
==== Selection of spatial function grid

Spatial functions are defined as a grid or a set of grids.  At a given position only one of the grids is used to calculate the spatial function displacement or uncertainty.  The implementation must uniquely identify the grid, if any, that applies at any location within the valid extents of the model.  If no grid applies at a location then the displacement and uncertainty of the element at that location are both zero.

[[formula-bilinear-interpolation]]
==== Bilinear grid interpolation

Spatial functions may be represented as regular grids defined in an interpolation CRS. The coordinates of a grid node are given by

x~i~ = x~o~ + i.x~s~ +
y~j~ = y~o~ + j.y~s~

where  x~o~, y~o~ are the coordinates of a reference point of the grid,  x~s~ and y~s~ are the grid spacing along the x and y axes respectively, and i and j are the column and row number of the grid node.  Note that the x and y grid spacing need not be equal.  For example, in a geographic interpolation coordinate system where x is longitude and y is latitude it may be preferable that x~s~ is approximately equal to y~s~/cos(y~m~), where y~m~ is the latitude of the middle of the grid, as this makes the grid cells approximately square (except at polar latitudes).

Model components are calculated using bilinear interpolation with respect to x and y between the nodes at the corners of the grid cell within which the calculation point lies, as shown in <<image_bilinear_interpolation>>.  Each element of the displacement is calculated independently.

[[image_bilinear_interpolation]]
image::bilinear_interpolation.png[title="Bilinear interpolation on a grid cell",width=300,scalewidth=7cm]

Bilinear interpolation is defined as follows:

The calculation point (x,y) is located in the grid cell between columns i and i+1, and rows j and j+1.

The weights are assigned to these nodes using the formulae:

W~i,j~ = ((x~i+1~-x)/x~s~) * ((y~j+1~-y)/y~s~) +
W~i+1,j~ = ((x-x~i~)/x~s~) * ((y~j+1~-y)/y~s~) +
W~i,j+1~ = ((x~i+1~-x)/x~s~) * ((y-y~j~)/y~s~) +
W~i+1,j+1~ = ((x-x~i~)/x~s~)*((y-y~j~)/y~s~)

The model components at (x,y) are calculated as the weighted average of the values at the nodes as, e.g.:

de = W~i,j~.de~i,j~ + W~i+1,j~.de~i+1,j~ + W~i,j+1~.de~i,j+1~ + W~i+1,j+1~.de~i+1,j+1~

// Above to be confirmed but above simplification may be more correct - model components from adjacent nodes are highly
// correlated so doesn't make sense to add as if they are independent.  Original text was
// 
// The displacement components de, dn, dh at (x,y) are calculated as the weighted average of the values at the nodes as, e.g.:
//
// de = W~i,j~.de~i,j~ + W~i+1,j~.de~i+1,j~ + W~i,j+1~.de~i,j+1~ + W~i+1,j+1~.de~i+1,j+1~
//
// The uncertainties eh, ev at (x,y) are calculated from the values at the nodes as, for example
//
// eh = √(W~i,j~*eh~i,j~^2^ + W~i+1,j~*eh~i+1,j~^2^ + W~i,j+1~*eh~i,j+1~^2^ + W~i+1,j+1~*eh~i+1,j+1~^2^)

[[formula-geocentric-bilinear-interpolation]]
==== Geocentric bilinear grid interpolation

A simple average of the east and north displacements may not be appropriate where a grid cell spans a wide longitude range, typically for grids in polar regions.  In this situation the directions of the east and north vectors may be quite different at nodes being averaged, as shown in <<image-near-pole-axes>> where their directions at nodes A and B and the evaluation point P differ significantly.

[[image-near-pole-axes]]
image::geocentric_bilinear_interpolation.png[title="East and north directions at near pole grid axes", width=200,scalewidth=7cm]

In this situation the bilinear interpolation of vector components can be adapted by reparametrizing the vectors to a common set of axes before forming the weighted average.

The geocentric bilinear interpolation method converts the displacement components from east and north components to geocentric X, Y, and Z components. These are consistently aligned at the grid nodes and can be scaled and summed using the bilinear interpolation formulae in <<formula-bilinear-interpolation>> to calculate the X, Y, Z components of displacement at the calculation point, which are then converted back to east and north components at the calculation point.

At longitude λ and latitude φ the geocentric displacement components dx, dy, dz are calculated from the east and north components de, dn as:

dx~i,j~ = -de~i,j~.sin(λ~i,j~) - dn~i,j~.cos(λ~i,j~).sin(φ~i,j~) +
dy~i,j~ = de~i,j~.cos(λ~i,j~) - dn~i,j~.sin(λ~i,j~).sin(φ~i,j~) +
dz~i,j~ = dn~i,j~.cos(φ~i,j~)

The X, Y, and Z directions are the same at any location, so the dx, dy, and dz displacements can be interpolated independently using bilinear interpolation, e.g.:

dx = W~i,j~.dx~i,j~ + W~i+1,j~.dx~i+1,j~ + W~i,j+1~.dx~i,j+1~ + W~i+1,j+1~.dx~i+1,j+1~

where the weights W~i,j~ are as defined in <<formula-bilinear-interpolation>>.

The displacement at the calculation point is then calculated as:

de = -dx.sin(λ) + dy * cos (λ) +
dn = -dx.cos(λ).sin(φ) - dy.sin(λ).sin(φ) + dz.cos(φ)

Note that this is only used to determine the horizontal displacement. The vertical displacement and uncertainties are computed using the bilinear formula above.

[[formula-time-function]]
=== Time functions

The time function f(_t_) for an element evaluates a scalar value by which the spatial function displacement is multiplied to determine the displacement at time _t_. For example, in a velocity model the spatial model represents the displacement that happens in one year and the time function evaluates the scale factor f(t) applied to the displacement at time t as the number of years since a function reference epoch  t~0~, i.e. f(t)=(_t_ - t~0~).

The deformation model metadata defines a temporal extent for the model from T~min~ to T~max~. At times before T~min~ and after T~max~ every time function is considered undefined and the model cannot be evaluated.

The time function is defined as the sum of one or more base functions. 

Each base time function is one of the types listed in the following table.

[[table-time-function-types]]
.Base time function types
[cols="2,8a"]
[options="header"]
|===
| Time function type|Description
| velocity | Defines a scale factor that is linear with time.  When multiplied by the spatial function this defines a constant velocity field, typically used to represent secular tectonic velocity.
| acceleration | Defines a rate of change of the velocity function.  This may be used where the velocity is changing at a constant rate.  This is sometimes used to model glacial isostatic adjustment.
| step | Defines an instantaneous change of displacement, typically used to model coseismic earthquake deformation.
| ramp | Defines displacement accumulating at a linear rate over a fixed period of time.  This can be used to simplistically represent post-seismic deformation.  In particular, combining several ramp functions can be used to create a piecewise linear time function that can emulate any time behavior to an arbitrary level of accuracy.
| exponential | Defines a displacement accumulating at an exponentially decaying rate after an event.  This is commonly used to approximate post-seismic deformation.  Often used in conjunction with a logarithmic model.
| logarithmic | Defines a displacement accumulating proportionally to the logarithm of elapsed time since an event.  This is commonly used to approximate post-seismic deformation.  It is often used in conjunction with an exponential model.
| hyperbolic tangent | Approximates a time behavior observed in slow slip events.
| cyclic | Represents cyclic behavior, such as deformation due to seasonal groundwater loading.

|===


The following table lists the reference formulae for each type of time function.

[[table-time-functions]]
.Time function reference formulae
[cols="2,5a,5a"]
[options="header"]
|===
|Time function type|Parameters|Formula (t~i,min~ &#8804; _t_ < t~i,max~)
|velocity| Function reference epoch t~0~ | f~r~(_t_) = (_t_ - t~0~)

|acceleration|Function reference epoch t~0~ |f~r~(_t_)= (_t_ - t~0~)^2^

|step | Event epoch t~v~ | f~r~(_t_) = 0 when t < t~v~, +
f~r~(_t_) = 1 when t &#8805; t~v~

|ramp|Start epoch t~s~ +
End epoch t~e~ | f~r~(_t_) =0 for _t_ < t~s~ +
f~r~(_t_) = (_t_-t~s~)/(t~e~-t~s~) for t~s~ &#8804; _t_ < t~e~ +
f~r~(_t_) = 1.0 for _t_ &#8805; t~e~

|exponential|Event epoch t~v~ +
Time constant &#964; | f~r~(_t_) = 0   for _t_ < t~v~ +
f~r~(_t_) = (1 - exp(-(_t_-t~v~)/&#964;)     for _t_ &#8805; t~v~

|logarithmic|Event epoch t~v~ +
Time constant &#964; | f~r~(_t_) = 0 for _t_ < t~v~ +
f~r~(_t_) = ln(1 + (_t_-t~v~)/&#964;) for  _t_ &#8805; t~v~

|hyperbolic tangent|Event epoch t~v~ +
Time constant &#964; | f~r~(_t_) = (1 + tanh( (_t_ - t~v~)/&#964;))/2 +
where tanh(x) = (e^x^ - e^-x^)/(e^x^ + e^-x^)

|cyclic|Frequency _f_ (cycles per year) +
Function reference epoch t~0~ |
f~r~(_t_) = sin(_f_(_t_ - t~0~)/2&#120587;)

|===


Each base time function is computed using the reference formula f~r~(_t_) as in table <<table-time-functions>> above.  The result can be modified by three epoch parameters, start epoch t~s~, end epoch t~e~, and function reference epoch t~0~, and a scale factor s.  (Note that the ramp function explicitly uses the start and end epoch, and the velocity, acceleration, and cyclic functions explicitly use the function reference epoch.)

The base time function f(_t_) is evaluated from the reference function f~r~(_t_) using these epochs as follows:

* If the start epoch is defined then the function is evaluated at the start epoch for all times before the start epoch.  If the end epoch is defined then the function is evaluated at the end epoch for all times after the end epoch.  That is:

+
--
f~1~(_t_) = f~r~(t~s~) if t~s~ is defined and _t_ < t~s~ +
f~1~(_t_) = f~r~(t~e~) if t~e~ is defined and _t_ > t~e~ +
f~1~(_t_) = f~r~(_t_) otherwise
--

* If the function reference epoch t~0~ is defined then a constant is added to f~1~ so that it evaluates to zero at the function reference epoch. That is:

+
--
f~2~(_t_) = f~1~(_t_) - f~1~(t~0~) if t~0~ is defined +
f~2~(_t_) = f~1~(_t_) otherwise
-- 

* If the scale factor s is defined then the function is multiplied by it:

+
--
f(_t_) = s.f~2~(_t_) if s is defined +
f(_t_) = f~2~(_t_) otherwise.
--

In these formulae all epochs _t_ are defined as a decimal year. 

A date/time _yyyy_-_mm_-__dd__T__HH__:__MM__:__SS__  is converted to a decimal year as follows. The year number _yyyy_ of the UTC epoch forms the integer part of the decimal year. The fractional part of the decimal year is determined by dividing the number of seconds between the beginning of the year _yyyy_-01-01T00:00:00Z and the date/time by the total number of seconds in the year (i.e. the number of seconds between _yyyy_-01-01T00:00:00Z and _yyy1_-01-01T00:00:00Z, where _yyy1_ is __yyyy__+1).

Note that there is a small ambiguity in this formulation due to the occasional introduction of leap seconds. This impacts calculations because 1) it is not known at the beginning of the year whether a leap second will be added, and 2) standard software libraries used to implement the time functions may not include leap seconds, and if they do there will often be a delay before updates including leap seconds are distributed to users.  In all realistic usages, apart from the step function at the event epoch, the difference in deformation from one second to the next is insignificant.  

Since leap seconds impart no practical difference to the deformation model calculations the decimal year is considered compliant whether or not it accounts for leap seconds - there are two nominally correct answers.

Future versions of this specification may add new base functions as required.

[[formula-elements]]
=== Combination of elements

To calculate the total displacement at a time and location, the displacement due to each element is calculated independently and summed. The total displacement is then applied to the coordinate. Displacement uncertainty is calculated similarly using the formula below.  The same input position coordinate is used for each element. Deformation components are not applied sequentially, that is the input coordinate is not updated by the first element before being used to calculate the deformation of the second element.

At a given time and location the values obtained from each element are combined to determine the overall displacement. For example, if there are n components for which the spatial model calculates de as de~1~, de~2~, … to de~n~, and the time function evaluates to f~1~, f~2~, … to f~n~ then the total displacement de is

de = f~1~.de~1~+ f~2~.de~2~+ … + f~n~.de~n~

The uncertainty eh or ev is the root sum of squares (RSS) of the uncertainty values determined for each element. For example,

eh = √(f~1~^2^.eh~1~^2^+ f~2~^2^.eh~2~^2^+ … + f~n~^2^.eh~n~^2^)

[formula-apply-displacement]
=== Applying the total displacement to a coordinate

The method used to add the calculated displacement to the reference coordinate is defined in the deformation model metadata. Two methods are defined - _addition_ described in <<formula-displacement-addition>> and _geocentric addition_ described in <<formula-displacement-geocentric-addition>>. The _addition_ method simply adds the displacements to the coordinates.  The _geocentric_ method accounts for the difference between a linear east offset and a longitude offset in polar regions. It is only applicable if the displacements are expressed as linear distance (e.g. meters) and the source and target coordinate system are geographic.

If the interpolation coordinate system is directly related to the source or target coordinate systems then applying the  displacement to a point may change its coordinate in the interpolation coordinate system, which in turn may change the calculated value of displacement.  In this case the calculation and application of displacement to an input coordinate may require iteration, as described in <<formula-iterative-application>>.

[[formula-displacement-addition]]
==== Addition method

The method of applying a displacement to a coordinate depends on the units of the displacement and the type of the source and target coordinate systems. 

For geographic coordinate systems at locations near the poles the alternative <<formula-displacement-geocentric-addition>> may be more suitable.

If the source and target coordinate systems are projected coordinate systems then the units must be meters and the east and north displacements are simply added to the easting, northing coordinates.

If the source and target coordinate systems are geographic coordinate systems and the east and north displacement units are degrees, then the displacements are added to the longitude and latitude coordinates.

If the source and target coordinate systems are geographic and the east and north displacement units are meters then the displacement components must be converted to degrees before being added to the longitude and latitude coordinates. The conversion from meters to degrees requires the ellipsoid parameters of the geographic coordinate system.

If a is the ellipsoid semi-major axis (e.g. 6378137.0), f is the flattening (e.g. 1.0/298.25722210), λ is the longitude, and φ is the latitude then corrections to longitude dλ and latitude dφ (in radians) are given by:


b = a.(1-f) +
dλ = de.√(b^2^sin^2^(φ)+a^2^cos^2^(φ))/a^2^cos(φ) +
dφ = dn.(b^2^sin^2^(φ)+a^2^cos^2^(φ))^3/2^/a^2^b^2^

Note that this formula does not account for the height of a calculation point above the ellipsoidal surface. The deformation model is assumed to represent deformation on the ellipsoidal surface, so the actual east and north offset of a point above or below this surface will be slightly different to that defined in the model.

The vertical displacement is always in meters and is simply added to the height coordinate.

[[formula-displacement-geocentric-addition]]
==== Geocentric addition method

The geocentric addition method is a more complex method than the addition method which is suitable for geographic coordinate systems at locations close to the poles. 

This method applies where the coordinates are in a geographic coordinate system and displacements are in meters. 

The horizontal displacements are applied using the following procedure:

* the horizontal displacement components are converted to geocentric displacement components using the formulae in
[[formula-geocentric-bilinear-interpolation]]
* the geographic longitude and latitude are converted to geocentric cartesian coordinates X,Y,Z.  For this calculation the ellipsoidal height is set to zero.
* the geocentric displacement components are added to the cartesian coordinates
* the cartesian coordinates are converted back to geographic coordinates.  The resultant longitude and latitude are used in the final coordinate (the ellipsoidal height is discarded).

Note that the height coordinate is not updated by this method - a vertical displacement is added directly to the height coordinate.

TBC _Add formulae for conversion lat/lon to XYZ and vice versa_

Standard formulae are used to convert geographic coordinates to and from geocentric cartesian coordinates. The input ellipsoidal height is set to zero before converting to Cartesian coordinates, and the resultant ellipsoidal height after converting back to geographic coordinates is discarded.

[[formula-iterative-application]]
=== Iterative calculation of inverse transformation

Calculating the inverse of the model requires an iterative solution if the interpolation coordinate system is dependent on the output coordinate system. The coordinate in the interpolation coordinate reference system is required to evaluate the displacement, but that coordinate is not known until the displacement has been calculated and applied to the input coordinate to derive the output coordinate.

This will apply in a forward transformation if the interpolation coordinate system is dependent on the target coordinate system, and in a reverse transformation if it is dependent on the source coordinate system.

The iterative calculation uses the following steps:

* use the input coordinate as an initial estimate for the output coordinate
* at each iteration:
** use the current estimate of the output coordinate to determine the displacement that applies
** apply this displacement to the input coordinate to obtain a new estimate for the output coordinate
** calculate the difference between the current and new estimates of the output coordinate
** if this difference is greater than the precision required for the inverse operation then iterate again, otherwise finish

Note that at the edge of the model it may not be possible to calculate the inverse transformation.  The model is undefined outside its spatial extent in the interpolation coordinate system.  If the transformation of a point near the edge of the model moves it to a location outside that extent, then the first step of the iterative calculation will fail.  This step uses the transformed coordinate as a first estimate for the untransformed coordinate.  However that will be a point outside the model, so calculating the transformation at that point is not possible.  A more sophisticated algorithm could address this, for example using the nearest point within the spatial extent of the model at the first iteration.

[[formula-conversion-between-epochs]]
=== Calculation of deformation between two epochs

The displacement de, dn and du to transform a coordinate between two epochs is calculated in a similar way to above except that the time functions are evaluated by taking the difference between the values at each epoch.  

To calculate the displacement from epoch t~0~ to epoch t~1~ the time factors in <<formula-elements>> are calculated for the i^th^ element as:

f~i,t1-t0~ = f~i~(t~1~) - f~i~(t~0~)

Note that for calculating displacement components this gives the same result as taking the difference between the displacement components calculated individually for each epoch.  However, this method must be used to give the correct value of the uncertainty of the displacement between two epochs.
